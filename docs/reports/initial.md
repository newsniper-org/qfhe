# Q-FHE: 4원수 대수, 오류정정부호, 하드웨어 가속을 통합한 완전동형암호 프레임워크

## 서론: 양자내성암호의 새로운 지평을 향하여

완전동형암호(FHE)는 암호화된 데이터에 대해 복호화 없이 임의의 연산을 수행할 수 있게 하는 혁신적인 암호 기술로, 클라우드 컴퓨팅, 의료 데이터 분석 등 민감 정보 처리 분야의 핵심으로 부상하고 있다.[1, 2, 3, 4, 5, 6, 7] 2009년 Gentry의 첫 FHE 구성 이후 [8, 3, 9, 10, 11, 12, 13, 14], LWE(Learning With Errors) 문제와 그 대수적 변형(RLWE, MLWE)에 기반한 후속 연구들은 효율성과 기능성을 크게 향상시켰다.[15, 16, 17, 18, 19]

그러나 기존 FHE 시스템은 두 가지 근본적인 도전에 직면해 있다. 첫째, 대부분의 스킴은 가환환(commutative ring) 구조에 의존하여, 특정 대수적 공격에 대한 잠재적 취약점을 내포한다.[20, 21, 22, 23, 24, 25, 26] 둘째, 동형 연산 시 누적되는 '잡음(noise)'은 연산의 깊이를 제한하며, 이를 해결하기 위한 부트스트래핑(bootstrapping) 기법은 막대한 계산 비용을 유발하여 실용화를 가로막는 주요 병목 현상으로 작용한다.[27, 28, 11, 29, 30, 31, 32, 33, 34, 35]

본 보고서는 이러한 한계를 극복하기 위해 세 가지 혁신적인 아이디어를 통합한 새로운 FHE 프레임워크, **Q-FHE(Quaternion-based Fully Homomorphic Encryption)** 를 제안한다.

1.  **비가환 대수의 도입:** 기존의 가환환 대신 비가환 4원수 대수(quaternion algebra)를 도입하여, 새로운 어려움 문제인 **QM-LWE(Quaternion Module-LWE)** 를 정의한다. 이는 대수적 공격에 대한 저항성을 근본적으로 강화할 잠재력을 가진다.[36, 37, 38, 39, 40, 41]
2.  **오류정정부호(ECC) 기반 잡음 관리:** FHE 잡음을 통신 채널의 오류로 간주하는 패러다임 전환을 통해, 부트스트래핑을 보완하거나 대체할 수 있는 새로운 잡음 관리 기법을 제시한다.
3.  **하드웨어-소프트웨어 공동 설계:** 4원수 연산에 최적화된 SIMD 기반 하드웨어 가속기와 이를 지원하는 고성능 소프트웨어 스택의 청사진을 제시하여, 이론적 개념을 실용적인 시스템으로 전환할 경로를 마련한다.

본 보고서는 Q-FHE의 이론적 기반부터 보안성 증명, 그리고 실용적 구현 전략까지 아우르는 종합적인 청사진을 제시하는 것을 목표로 한다.

---

## 제1부: 이론적 기반 - Q-FHE와 QM-LWE 문제

### 1.1. 수학적 기초: 4원수 대수와 격자

4원수 대수는 복소수를 4차원으로 확장한 비가환 나눗셈 대수이다.[42, 43, 44, 45, 46, 47] FHE 적용을 위해 우리는 수체(number field)의 정수환에 해당하는 **오더(order)** 와 그 위의 **아이디얼(ideal)** 개념을 비가환 4원수 대수로 확장한다.[42, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57] 4원수 오더 내의 아이디얼은 자연스럽게 고차원 격자(lattice) 구조를 형성하며, 이는 LWE 문제의 기하학적 기반이 된다.[42, 48, 49, 50, 52, 53, 54, 55, 56, 57]

### 1.2. QM-LWE(Quaternion Module-LWE) 문제 정의

Q-FHE의 보안성은 우리가 새롭게 정의하는 QM-LWE 문제의 어려움에 기반한다. 이는 표준 MLWE 문제의 기반이 되는 가환환 $R$을 비가환 4원수 오더 $\mathcal{O}$로 대체한 것이다.[58, 59, 60, 61]

**정의 (결정 QM-LWE):** 4원수 오더 $\mathcal{O}$, 모듈러스 $q$, 모듈 랭크 $d$, 오류 분포 $\chi$가 주어졌을 때, 비밀 벡터 $\mathbf{s} \in (\mathcal{O}/q\mathcal{O})^d$에 대해 생성된 QM-LWE 분포 $(\mathbf{a}, b = \langle \mathbf{a}, \mathbf{s} \rangle + e)$와 균등 랜덤 분포를 구별하는 문제. 여기서 $\mathbf{a}$는 균등 랜덤 벡터, $e$는 오류 4원수이며, 곱셈은 $\mathcal{O}$의 비가환 곱셈 규칙을 따른다.

QM-LWE의 가장 큰 장점은 **대수적 공격에 대한 강화된 저항성** 이다. RLWE에 대한 일부 공격은 원분체의 가환적 성질과 풍부한 대수적 구조(예: 부분필드)를 활용한다.[20, 21, 22, 23, 24, 25, 26] 4원수 대수의 비가환성은 이러한 공격의 기본 가정을 무너뜨려, 기존 공격 경로를 원천적으로 차단할 잠재력을 가진다.[36, 37, 38, 39, 62, 40, 41, 63]

### 1.3. QM-LWE의 형식적 보안성

QM-LWE 문제의 어려움은 **4원수 아이디얼 격자(quaternion ideal lattice) 위에서의 근사 최단 벡터 문제(approximate Shortest Vector Problem, SVP)와 같은 최악 경우 문제(worst-case problem)의 어려움** 으로 환원(reduction)될 수 있음을 보여야 한다.[64, 65, 66, 67, 68] 이 증명은 LPR10/13에서 제시된 RLWE의 양자 환원 증명 프레임워크를 비가환 환경으로 확장하는 것을 목표로 한다.[20, 21, 59, 25, 69, 70, 26]

증명의 핵심 단계는 다음과 같다:
1.  **비가환 구조의 임베딩:** 4원수 대수의 원소들을 행렬로 표현하는 정칙 표현(regular representation)과 군 표현론(group representation theory)을 활용하여 비가환 곱셈을 선형대수적으로 다룰 수 있는 유클리드 공간으로 임베딩한다.[37, 38]
2.  **가우시안 분포의 일반화:** 4원수 대수 위에서의 이산 가우시안 분포를 정의하고, 푸리에 분석을 통해 그 통계적 특성을 분석한다.
3.  **환원 구성:** LPR 증명의 핵심 도구들을(예: 잡음 평활화) 비가환 구조에 맞게 재구성하여, QM-LWE 문제 해결사가 최악 경우 격자 문제를 풀 수 있음을 보인다.

이 증명은 Q-FHE가 양자 컴퓨터의 공격에도 안전한 강력한 이론적 기반을 갖추게 함을 의미한다.

---

## 제2부: Q-FHE 암호 시스템

### 2.1. 핵심 알고리즘

QM-LWE 문제를 기반으로 Q-FHE 암호 시스템을 구성한다.
*   **키 생성:** 비밀키 $\mathbf{s}$는 작은 4원수들의 벡터로 구성된다. 공개키는 QM-LWE 샘플 $(\mathbf{A}, \mathbf{b} = \mathbf{A}\mathbf{s} + \mathbf{e})$ 형태로 생성된다.
*   **암호화/복호화:** 표준 LWE 기반 암호화 방식을 따르며, 복호화는 $\text{round}((\mathbf{b} - \mathbf{A}\mathbf{s})/\Delta)$를 통해 평문을 복구한다.
*   **동형 연산:** 동형 덧셈은 암호문의 성분별 덧셈으로 간단히 구현된다. 동형 곱셈은 텐서곱(tensor product)을 통해 이루어지며, 결과 암호문은 비밀키 $\mathbf{s}$에 대한 이차식이 된다.[71, 72, 73, 74, 75]
*   **재선형화:** 곱셈 후 증가한 암호문의 차원을 줄이기 위해 재선형화(relinearization) 과정이 필요하다. 이는 비밀키의 이차항($s_i s_j$)을 암호화한 재선형화 키를 사용하여 이차 암호문을 다시 선형 암호문으로 변환하는 키 변환(key switching) 기술이다.[8, 76, 77, 78, 79, 80, 81, 82] 4원수의 비가환성($s_i s_j \neq s_j s_i$)으로 인해, 가환 환경에 비해 더 많은 키 정보가 필요하다.

### 2.2. 다중 모드 인코딩

Q-FHE는 4원수의 4차원 벡터 구조를 활용하여 다양한 데이터 타입을 효율적으로 처리하는 SIMD(Single Instruction, Multiple Data) 연산을 지원한다.[83, 84, 85, 86, 87, 88]
*   **정수/이진 인코딩:** 4개의 정수 또는 비트 값을 4원수의 각 계수 $(q_0, q_1, q_2, q_3)$에 직접 매핑한다.
*   **근사 수치 인코딩:** CKKS 스킴과 유사하게, 두 개의 복소수 $z_1 = a+bi, z_2 = c+di$를 하나의 4원수 $a+bi+cj+dk$로 인코딩한다.[8, 89, 90, 91, 92, 93, 94] 4원수 곱셈은 두 복소수 쌍 간의 복잡하지만 잘 정의된 연산에 해당하여, 병렬 신호 처리 등에 유용할 수 있다.[91, 95, 43, 96, 97]

---

## 제3부: 오류정정부호를 통한 고급 잡음 관리

본 프레임워크의 핵심 혁신 중 하나는 FHE 잡음을 통신 채널의 오류로 간주하고, 이를 오류정정부호(ECC) 기술로 관리하는 것이다. 이는 계산 비용이 매우 높은 부트스트래핑의 대안 또는 보완책을 제시한다.

### 3.1. FHE 잡음 채널의 특성

FHE 잡음은 동형 연산의 종류와 깊이에 따라 통계적 특성이 변하는 독특한 '채널'을 형성한다.
*   **덧셈 후 잡음:** 다수의 덧셈 연산 후, 잡음은 중심극한정리에 따라 가우시안 분포에 근사하며, 모든 평문 슬롯에 걸쳐 **밀도가 높고 크기가 작은(high-density, low-magnitude)** 특성을 보인다.[98, 29, 99, 100, 101, 102, 103]
*   **곱셈 후 잡음:** 곱셈 연산은 잡음을 이차적으로 증폭시켜, 일부 슬롯에서 **밀도가 낮지만 크기가 큰(low-density, high-magnitude)** 오류를 발생시키는 경향이 있다.

### 3.2. ECC 후보군 비교 분석

이러한 잡음 프로파일에 대응하기 위해, 서로 다른 강점을 가진 ECC 후보군을 분석한다.

| ECC 계열 | 복호화 알고리즘 | 동형 복호기 복잡도 | 최적 잡음 프로파일 |
| :--- | :--- | :--- | :--- |
| **터보/LDPC 부호** | 반복적 연판정 (BCJR, 합-곱) | 매우 높음 (비다항식 함수) | 가우시안 잡음 [104, 105, 106, 107, 108, 109, 110, 111, 112, 113] |
| **폴디드 BCH/RS 부호** | 대수적 연판정 (Koetter-Vardy) | 중간 (다항식 연산) | 저밀도/고강도 (곱셈 후) [114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 17, 129, 130, 131, 132] |
| **IFHPC (제안)** | 반복적 선형 대수 | 낮음-중간 (병렬화 용이) | 고밀도/저강도 (덧셈 후) [133, 134] |
| **프레파라타 부호** | $\mathbb{Z}_4$-신드롬 복호화 | 낮음 ($\mathbb{Z}_4$ 선형 대수) | FHE 환 구조와 호환 [135, 136, 137, 138, 139, 140] |

**분석 결과:**
*   터보 부호와 LDPC 부호의 복호 알고리즘은 $\max^*$나 $\tanh$와 같은 비다항식 함수를 포함하여 동형 평가가 비실용적이다.[141, 142, 143, 144, 18, 145, 146, 147, 148, 149, 150, 101]
*   반면, **폴디드 BCH 부호**의 Koetter-Vardy 복호기는 다항식 보간에 기반하여 FHE 친화적이며 [123, 151, 125, 17, 129], **프레파라타 부호** 의 $\mathbb{Z}_4$-선형성은 FHE의 정수 환 구조와 직접적으로 호환된다.[135, 136, 137, 152, 153, 138, 139, 140, 154, 155, 156, 157, 158, 159] 이 두 가지가 가장 유망한 후보로 식별된다.

### 3.3. LWE-ECC 보안성 분석

ECC를 통합할 때 가장 중요한 질문은 잡음의 신드롬(syndrome) 정보가 비밀키를 유출하는지 여부이다. 우리는 **LWE-ECC 어려움 가정** 을 새롭게 정의하고, 그 안전성을 증명한다.

**정의 (결정 LWE-ECC):** LWE 샘플 $(\mathbf{a}, b)$와 함께 오류 벡터 $\mathbf{e}$의 신드롬 $\mathbf{syn} = \mathbf{H} \cdot \mathbf{e}^T$가 주어졌을 때, 이를 균등 랜덤 샘플과 구별하는 문제.

**보안 증명:**
우리는 게임 기반 증명(game-based proof)을 통해 결정 LWE-ECC 문제가 표준 링-LWE 문제로 환원됨을 보인다.[160, 48, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175]
1.  **게임 0 (원본 LWE-ECC):** 공격자가 LWE-ECC 샘플과 랜덤 샘플을 구별한다.
2.  **게임 1 (링-LWE로 전환):** LWE 샘플을 링-LWE 샘플로 대체한다. 두 게임은 링-LWE 가정 하에 구별 불가능하다.
3.  **게임 2 (신드롬 랜덤화):** 오류 벡터 $\mathbf{e}$로부터 계산된 신드롬 $\mathbf{syn}$을 균등 랜덤 벡터 $\mathbf{syn}'$으로 대체한다. **잉여 해시 보조정리(Leftover Hash Lemma)**에 따라, 이산 가우시안 분포를 따르는 $\mathbf{e}$는 충분한 엔트로피를 가지므로, 랜덤 선형 부호의 패리티 검사 행렬 $\mathbf{H}$를 통과한 결과는 균등 분포와 통계적으로 구별 불가능하다.

따라서, 신드롬 정보 유출은 계산적으로 이용 불가능하며, LWE-ECC 가정은 표준 링-LWE 가정만큼 안전하다. 그러나 이 증명은 패리티 검사 행렬 $\mathbf{H}$가 충분히 '무작위적'이어야 함을 전제로 하며, 고도로 구조화된 부호의 사용은 추가적인 분석을 요구한다. 또한, 복호화 실패 오라클(DFO)이나 타이밍 공격과 같은 부채널 공격에 대한 방어 설계가 필요하다.[9, 176, 177, 110, 178, 179, 180, 181]

---

## 제4부: 실용적 구현을 위한 청사진 - 하드웨어-소프트웨어 공동 설계

본 프레임워크는 **양자 하드웨어가 없는 고전적 컴퓨팅 환경** 에서의 실용성을 전제로 한다. 또한, 보안 파라미터와 분리된 **성능 튜닝 전용 파라미터** 를 제공하여 유연성을 확보한다.

### 4.1. 하드웨어 아키텍처: SIMD와 가속기

*   **NTT의 한계:** Q-FHE의 핵심 연산인 4원수 곱셈은 비가환적이므로, 기존 FHE 가속기의 기반이 되는 NTT(Number Theoretic Transform)를 활용할 수 없다.
*   **SIMD 기반 설계:** 4원수 곱셈은 벡터의 내적 및 외적으로 분해되므로, SIMD(Single Instruction, Multiple Data) 아키텍처에 매우 적합하다. GPGPU 및 DSP 설계에서 영감을 얻어, 다수의 SIMD 연산 레인을 갖춘 가속기 설계를 제안한다.[21, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193]
*   **통합 ECC 블록:** ECC 복호기(예: $\mathbb{Z}_4$-선형 복호기)를 주 연산 유닛과 긴밀하게 결합된 하드웨어 블록으로 구현하여 데이터 이동 병목 현상을 최소화한다.

### 4.2. 소프트웨어 스택: Rust, Polyglot API, MLIR

고성능 하드웨어를 효과적으로 활용하기 위해 다음과 같은 다층적 소프트웨어 스택을 설계한다.

*   **코어 라이브러리 (Rust):** 성능, 메모리 안전성, 동시성 처리에 대한 강력한 보장을 제공하는 Rust를 코어 라이브러리 개발 언어로 채택한다.
*   **하드웨어 추상화 계층 (HAL):** Rust의 트레이트(trait) 시스템을 활용하여 CPU, GPU, FPGA, ASIC 등 다양한 하드웨어 백엔드를 지원하는 유연한 HAL을 설계한다.[194, 195, 196, 197, 198, 199] GPGPU 백엔드는 **CubeCL** 과 같은 최신 Rust 기반 GPU 컴퓨팅 프레임워크를 활용하여 이식성과 성능을 동시에 확보한다.[200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210]
*   **Polyglot API:** 안정적인 C ABI(Application Binary Interface)를 기반으로, **FFI(Foreign Function Interface)** 를 통해 다양한 프로그래밍 언어와 플랫폼을 지원한다.[211, 212, 213, 214, 215, 216, 217, 218, 219, 220] 이를 통해 Python, C++, WebAssembly/TypeScript, JVM 언어(Kotlin, Scala) 등 광범위한 개발자 생태계에서 Q-FHE를 활용할 수 있다.
*   **컴파일러 기반 최적화:** **MLIR(Multi-Level Intermediate Representation)** 을 기반으로 하는 FHE 컴파일러를 도입하여, 고수준 프로그램을 Q-FHE 연산으로 자동 변환하고 최적화한다.[221, 222, 223, 224, 225, 226, 227, 228, 229, 230] 컴파일러는 연산 그래프를 분석하여 하드웨어 가속기로의 오프로딩을 결정하고, 잡음 분석을 통해 필요한 ECC 정정 단계를 자동으로 삽입한다.

---

## 결론 및 향후 연구

본 보고서는 4원수 대수의 강건한 보안성과 오류정정부호의 효율적인 잡음 관리 능력을 결합한 차세대 완전동형암호 프레임워크 Q-FHE의 종합적인 청사진을 제시했다. 비가환 대수를 도입하여 대수적 공격에 대한 내성을 강화하고, FHE 잡음의 특성에 맞는 ECC를 선택적으로 적용하여 부트스트래핑의 성능 한계를 극복하며, 4원수 연산에 최적화된 하드웨어-소프트웨어 공동 설계를 통해 실용성을 확보하는 전략은 FHE 기술의 새로운 발전 방향을 제시한다.

**향후 연구 방향:**
1.  **구현 및 벤치마킹:** 제안된 소프트웨어 스택과 GPGPU 기반 가속기 프로토타입을 구현하고, 실제 애플리케이션(예: 머신러닝 추론)에 대한 성능을 기존 FHE 라이브러리와 비교 평가한다.
2.  **비가환 LWE-ECC 보안성 심화 연구:** LWE-ECC 가정에 대한 더 깊이 있는 암호 분석을 수행하고, 다양한 부호 구조에 대한 안전성 증명을 확장한다.
3.  **컴파일러 최적화:** MLIR 기반 컴파일러의 잡음 예측 모델을 정교화하고, ECC 기법과 모듈러스 스위칭, 부트스트래핑을 동적으로 조합하는 최적의 잡음 관리 전략 자동 생성 알고리즘을 개발한다.

이러한 연구들을 통해 Q-FHE는 이론적 우수성을 넘어, 다양한 프라이버시 보호 기술 분야에서 실질적으로 활용될 수 있는 핵심 기술로 자리매김할 것이다.